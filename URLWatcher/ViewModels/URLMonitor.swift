import Foundation
import Combine

class URLMonitor: ObservableObject {
    @Published var items: [URLItem] = []
    private var timers: [UUID: Timer] = [:]
    private var countdownTimers: [UUID: Timer] = [:]
    private let saveKey = "URLMonitorItems"
    let requestManager = URLRequestManager()
    
    init() {
        print("üöÄ URLMonitor init() aufgerufen")
        load()
        print("üìä Items nach Load: \(items.count)")
        
        // Sofort alle nicht-pausierten Items starten
        DispatchQueue.main.async { [weak self] in
            self?.startAll()
        }
    }
    
    func startAll() {
        for item in items where item.isEnabled {
            schedule(item: item)
        }
    }
    
    func schedule(item: URLItem) {
        print("‚è∞ Schedule-Funktion aufgerufen f√ºr Item: \(item.id)")
        
        cancel(item: item)
        guard item.isEnabled else { 
            print("‚è∞ Item ist deaktiviert - Timer nicht gestartet")
            return 
        }
        
        // Verbleibende Zeit auf Intervall setzen
        if let index = items.firstIndex(where: { $0.id == item.id }) {
            items[index].remainingTime = item.interval
            print("‚è∞ RemainingTime f√ºr Item \(item.id) auf \(item.interval) gesetzt")
        } else {
            print("‚ùå Item \(item.id) nicht in items-Array gefunden beim Schedule")
            return
        }
        
        // Einziger Timer f√ºr Countdown und Checks (jede Sekunde)
        let timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            
            DispatchQueue.main.async {
                guard let currentIndex = self.items.firstIndex(where: { $0.id == item.id }) else { 
                    print("‚ùå Item \(item.id) nicht in Timer-Callback gefunden - Timer wird gestoppt")
                    self.timers[item.id]?.invalidate()
                    self.timers.removeValue(forKey: item.id)
                    return 
                }
                
                // Countdown aktualisieren
                if self.items[currentIndex].remainingTime > 0 {
                    self.items[currentIndex].remainingTime -= 1.0
                }
                
                // Check ausl√∂sen wenn Countdown bei 0 ist
                if self.items[currentIndex].remainingTime <= 0 {
                    self.check(itemID: item.id)
                    // Countdown auf Intervall zur√ºcksetzen
                    self.items[currentIndex].remainingTime = self.items[currentIndex].interval
                }
            }
        }
        timers[item.id] = timer
        print("‚è∞ Timer f√ºr Item \(item.id) erfolgreich gestartet")
    }
    
    // startCountdown und stopCountdown wurden entfernt - Countdown wird jetzt vom Haupt-Timer gehandhabt
    
    func rescheduleTimer(for item: URLItem) {
        cancel(item: item)
        guard item.isEnabled else { return }
        
        // Verbleibende Zeit auf Intervall setzen
        if let index = items.firstIndex(where: { $0.id == item.id }) {
            items[index].remainingTime = item.interval
        }
        
        // Einziger Timer f√ºr Countdown und Checks (jede Sekunde)
        let timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            
            DispatchQueue.main.async {
                guard let currentIndex = self.items.firstIndex(where: { $0.id == item.id }) else { return }
                
                // Countdown aktualisieren
                if self.items[currentIndex].remainingTime > 0 {
                    self.items[currentIndex].remainingTime -= 1.0
                }
                
                // Check ausl√∂sen wenn Countdown bei 0 ist
                if self.items[currentIndex].remainingTime <= 0 {
                    self.check(itemID: item.id)
                    // Countdown auf Intervall zur√ºcksetzen
                    self.items[currentIndex].remainingTime = self.items[currentIndex].interval
                }
            }
        }
        timers[item.id] = timer
    }
    
    func cancel(item: URLItem) {
        timers[item.id]?.invalidate()
        timers.removeValue(forKey: item.id)
        
        // Countdown zur√ºcksetzen
        if let index = items.firstIndex(where: { $0.id == item.id }) {
            items[index].remainingTime = 0
        }
    }
    
    func togglePause(for item: URLItem) {
        if let index = items.firstIndex(where: { $0.id == item.id }) {
            items[index].isEnabled.toggle()
            save()
            if !items[index].isEnabled {
                cancel(item: items[index])
            } else {
                schedule(item: items[index])
            }
        }
    }
    
    func remove(item: URLItem) {
        // Sicherer Remove mit Timer-Cleanup
        cancel(item: item)
        items.removeAll { $0.id == item.id }
        save()
    }
    
    func duplicate(item: URLItem) {
        print("üîÑ Dupliziere Item: \(item.title ?? item.url.absoluteString)")
        
        // Erstelle eine Kopie des Items
        var duplicatedItem = item
        duplicatedItem.id = UUID() // Neue eindeutige ID
        duplicatedItem.isEnabled = false // Startet pausiert
        duplicatedItem.pendingRequests = 0
        duplicatedItem.remainingTime = 0
        duplicatedItem.history = [] // Keine Historie f√ºr Duplikate
        // currentStatus wird automatisch aus history abgeleitet
        
        // Intelligente Titel-Generierung f√ºr Duplikate
        let baseTitle = item.title ?? "URL"
        let existingTitles = items.compactMap { $0.title }
        duplicatedItem.title = baseTitle.generateUniqueCopyName(existingTitles: existingTitles)
        
        print("üìù Generierter Titel: \(duplicatedItem.title ?? "Kein Titel")")
        
        // F√ºge das duplizierte Item hinzu
        items.append(duplicatedItem)
        
        // Force UI Update
        objectWillChange.send()
        
        // Speichere die √Ñnderungen
        save()
        
        print("‚úÖ Item erfolgreich dupliziert")
    }
    
    func createNewItem() {
        print("‚ûï Erstelle neues Item")
        
        let newItem = URLItem(url: URL(string: "https://")!, interval: 10, isEnabled: false)
        
        // F√ºge das neue Item hinzu
        items.append(newItem)
        
        // Force UI Update
        objectWillChange.send()
        
        // Speichere die √Ñnderungen
        save()
        
        print("‚úÖ Neues Item erstellt")
    }
    
    func addItem(_ item: URLItem) {
        print("addItem() aufgerufen f√ºr Item: \(item.id)")
        
        // Item ist bereits validiert - direkt hinzuf√ºgen und starten
        var validItem = item
        validItem.isEnabled = true
        
        items.insert(validItem, at: 0)
        schedule(item: validItem)
        save()
        print("Item erfolgreich hinzugef√ºgt und gestartet")
    }
    
    func testURL(_ urlString: String, completion: @escaping (Bool, String?) -> Void) {
        guard let url = URL(string: urlString) else {
            completion(false, "Ung√ºltige URL")
            return
        }
        
        var request = URLRequest(url: url)
        request.timeoutInterval = 10.0 // 10 Sekunden Timeout
        request.httpMethod = "HEAD" // Nur Header abrufen, nicht den ganzen Inhalt
        
        let task = URLSession.shared.dataTask(with: request) { data, response, error in
            DispatchQueue.main.async {
                if let error = error {
                    completion(false, "URL nicht erreichbar: \(error.localizedDescription)")
                } else if let httpResponse = response as? HTTPURLResponse {
                    if httpResponse.statusCode >= 200 && httpResponse.statusCode < 400 {
                        completion(true, nil)
                    } else {
                        completion(false, "HTTP-Fehler: \(httpResponse.statusCode)")
                    }
                } else {
                    completion(false, "Keine Antwort von der URL")
                }
            }
        }
        task.resume()
    }
    

    
    // confirmNewItemWithValues wurde entfernt - neue Items werden √ºber addItem() hinzugef√ºgt
    
    func confirmEditingWithValues(for item: URLItem, urlString: String, title: String?, interval: Double, isEnabled: Bool, enabledNotifications: Set<URLItem.NotificationType>? = nil) {
        if let index = items.firstIndex(where: { $0.id == item.id }) {
            print("üíæ Best√§tige Bearbeitung f√ºr Item: \(item.title ?? item.url.absoluteString)")
            
            // URL validieren und erstellen
            guard let url = URL(string: urlString) else {
                print("‚ùå Ung√ºltige URL: \(urlString)")
                return
            }
            
            // Pr√ºfe, ob sich die URL ge√§ndert hat
            let urlChanged = items[index].url.absoluteString != url.absoluteString
            
            // Pr√ºfe, ob sich isEnabled ge√§ndert hat
            let wasEnabled = items[index].isEnabled
            let isEnabledChanged = wasEnabled != isEnabled
            
            // Aktualisiere das Item
            items[index].url = url
            items[index].title = title
            items[index].interval = interval
            items[index].isEnabled = isEnabled
            
            if let enabledNotifications = enabledNotifications {
                items[index].enabledNotifications = enabledNotifications
            }
            
            // History zur√ºcksetzen, wenn sich die URL ge√§ndert hat
            if urlChanged {
                print("üîÑ URL ge√§ndert - History wird zur√ºckgesetzt")
                resetHistory(for: items[index])
            }
            
            // Timer-Management basierend auf isEnabled √Ñnderung
            if isEnabledChanged {
                if isEnabled {
                    // Item wurde aktiviert - Timer starten
                    print("‚ñ∂Ô∏è Timer f√ºr Item starten: \(items[index].title ?? items[index].url.absoluteString)")
                    schedule(item: items[index])
                } else {
                    // Item wurde deaktiviert - Timer stoppen
                    print("‚è∏Ô∏è Timer f√ºr Item stoppen: \(items[index].title ?? items[index].url.absoluteString)")
                    cancel(item: items[index])
                }
            }
            
            // Force UI Update
            objectWillChange.send()
            
            // Speichere die √Ñnderungen
            save()
            
            print("‚úÖ Bearbeitung best√§tigt")
        }
    }
    
    // confirmNewItem und cancelNewItem wurden entfernt - neue Items werden √ºber addItem() hinzugef√ºgt
    
    func removeAllItems() {
        // Alle Timer stoppen
        for (_, timer) in timers {
            timer.invalidate()
        }
        timers.removeAll()
        
        // Alle Items l√∂schen
        items.removeAll()
        save()
    }
    
    func resetHistory(for item: URLItem) {
        if let index = items.firstIndex(where: { $0.id == item.id }) {
            // Historie komplett l√∂schen
            items[index].history.removeAll()
            
            // Request-Manager zur√ºcksetzen
            requestManager.resetHistory(for: item.id)
            
            save()
        }
    }
    
    func moveItems(from source: IndexSet, to destination: Int) {
        items.move(fromOffsets: source, toOffset: destination)
        save()
    }
    
    func pauseAllItems() {
        for index in items.indices {
                    if items[index].isEnabled {
            items[index].isEnabled = false
                cancel(item: items[index])
            }
        }
        save()
    }
    
    func resetAllHistories() {
        for index in items.indices {
            // Historie komplett l√∂schen
            items[index].history.removeAll()
        }
        // Request-Manager zur√ºcksetzen
        requestManager.resetAllHistories()
        save()
    }
    

    
    func toggleEditing(for item: URLItem) {
        // Diese Funktion ist nicht mehr ben√∂tigt, da nur noch Modal-Editor verwendet wird
        print("‚ö†Ô∏è toggleEditing() ist veraltet - Modal-Editor wird verwendet")
    }
    
    func cancelEditing(for item: URLItem) {
        // Diese Funktion ist nicht mehr ben√∂tigt, da nur noch Modal-Editor verwendet wird
        print("‚ö†Ô∏è cancelEditing() ist veraltet - Modal-Editor wird verwendet")
    }
    
    func removeEmptyItems() {
        // Entferne leere Eintr√§ge, aber behalte immer mindestens einen
        // URLs sind bereits validiert, da sie URL-Objekte sind
        // Keine leeren URLs mehr m√∂glich
        // Kein automatisches Speichern hier
    }
    
    func findFirstEmptyItem() -> URLItem? {
        // URLs sind bereits validiert, da sie URL-Objekte sind
        return nil
    }
    
    func ensureMinimumOneItem() {
        // Diese Funktion ist nicht mehr n√∂tig, da neue Items nicht mehr automatisch erstellt werden
        // Neue Items werden nur √ºber createNewItem() erstellt
    }
    
    func cleanupAndSave() {
        removeEmptyItems()
        save()
    }
    
    func check(itemID: UUID) {
        guard let index = items.firstIndex(where: { $0.id == itemID }) else { return }
        let item = items[index]
        // URL ist bereits validiert, da es ein URL-Objekt ist
        
        // Pending Requests Counter erh√∂hen
        items[index].pendingRequests += 1
        
        requestManager.checkURL(for: item) { [weak self] status, httpStatusCode, responseSize, responseTime, diff in
            guard let self = self else { return }
            guard let currentIndex = self.items.firstIndex(where: { $0.id == itemID }) else { return }
            
            // Pending Requests Counter verringern
            self.items[currentIndex].pendingRequests = max(0, self.items[currentIndex].pendingRequests - 1)
            
            // DiffInfo erstellen falls Diff vorhanden
            var diffInfo: URLItem.DiffInfo? = nil
            if let diff = diff {
                let changedLines = diff.components(separatedBy: .newlines).filter { line in
                    line.hasPrefix("+") || line.hasPrefix("-")
                }
                let previewLines = Array(changedLines.prefix(20))
                diffInfo = URLItem.DiffInfo(
                    totalChangedLines: changedLines.count,
                    previewLines: previewLines
                )
            }
            
            // History-Eintrag erstellen
            self.items[currentIndex].history.insert(URLItem.HistoryEntry(
                date: Date(),
                status: status,
                httpStatusCode: httpStatusCode,
                diffInfo: diffInfo,
                responseSize: responseSize,
                responseTime: responseTime
            ), at: 0)
            
            if self.items[currentIndex].history.count > 1000 {
                self.items[currentIndex].history.removeLast()
            }
            
            // Notification senden
            NotificationManager.shared.notifyIfNeeded(for: self.items[currentIndex], status: status, httpStatusCode: httpStatusCode)
        }
    }
    

    

    
    func save() {
        print("üíæ Save-Funktion aufgerufen")
        print("üìä Anzahl Items zum Speichern: \(items.count)")
        
        // Debug: Alle Items vor dem Speichern auflisten
        print("üìã Items vor dem Speichern:")
        for (index, item) in items.enumerated() {
            print("  \(index): \(item.id) - \(item.title ?? item.url.absoluteString)")
        }
        
        // Pr√ºfe auf Duplikate in der Liste
        let duplicateIDs = Dictionary(grouping: items, by: { $0.id })
            .filter { $1.count > 1 }
            .keys
        
        if !duplicateIDs.isEmpty {
            print("‚ö†Ô∏è Warnung: Duplikate in der Items-Liste gefunden:")
            for duplicateID in duplicateIDs {
                let duplicates = items.filter { $0.id == duplicateID }
                print("  ID \(duplicateID): \(duplicates.count) mal vorhanden")
                for (index, duplicate) in duplicates.enumerated() {
                    print("    \(index): \(duplicate.title ?? duplicate.url.absoluteString)")
                }
            }
        }
        
        // Konvertiere zu PersistableURLItems (ohne Historie)
        let persistableItems = items.map { PersistableURLItem(from: $0) }
        
        if let data = try? JSONEncoder().encode(persistableItems) {
            UserDefaults.standard.set(data, forKey: saveKey)
            UserDefaults.standard.synchronize() // Sofort synchronisieren
            print("‚úÖ Items erfolgreich gespeichert (ohne Historie)")
            
            // Debug: Speichergr√∂√üe anzeigen
            print("üì¶ Speichergr√∂√üe: \(data.count) bytes")
            
            // Validierung: Versuche die Daten sofort wieder zu laden
            if let savedData = UserDefaults.standard.data(forKey: saveKey),
               let decodedPersistableItems = try? JSONDecoder().decode([PersistableURLItem].self, from: savedData) {
                let decodedItems = decodedPersistableItems.map { $0.toURLItem() }
                print("‚úÖ Validierung erfolgreich: \(decodedItems.count) Items geladen")
                if decodedItems.count != items.count {
                    print("‚ö†Ô∏è Warnung: Anzahl der gespeicherten Items (\(decodedItems.count)) stimmt nicht mit aktueller Anzahl (\(items.count)) √ºberein")
                }
                
                // Pr√ºfe auf Duplikate in den geladenen Daten
                let loadedDuplicateIDs = Dictionary(grouping: decodedItems, by: { $0.id })
                    .filter { $1.count > 1 }
                    .keys
                
                if !loadedDuplicateIDs.isEmpty {
                    print("‚ö†Ô∏è Warnung: Duplikate in den geladenen Daten gefunden:")
                    for duplicateID in loadedDuplicateIDs {
                        let duplicates = decodedItems.filter { $0.id == duplicateID }
                        print("  ID \(duplicateID): \(duplicates.count) mal vorhanden")
                    }
                }
            } else {
                print("‚ùå Validierung fehlgeschlagen: Items konnten nicht wieder geladen werden")
            }
        } else {
            print("‚ùå Fehler beim Encodieren der Items")
            
            // Debug: Versuche herauszufinden, welches Item das Problem verursacht
            for (index, persistableItem) in persistableItems.enumerated() {
                do {
                    _ = try JSONEncoder().encode(persistableItem)
                    print("‚úÖ Item \(index) (\(persistableItem.id)) kann encodiert werden")
                } catch {
                    print("‚ùå Item \(index) (\(persistableItem.id)) kann NICHT encodiert werden: \(error)")
                }
            }
        }
    }
    
    func load() {
        print("üìÇ Load-Funktion aufgerufen")
        
        if let data = UserDefaults.standard.data(forKey: saveKey) {
            print("üì¶ Daten gefunden, Gr√∂√üe: \(data.count) bytes")
            
            // Versuche zuerst als PersistableURLItems zu laden (neues Format)
            if let decodedPersistable = try? JSONDecoder().decode([PersistableURLItem].self, from: data) {
                self.items = decodedPersistable.map { $0.toURLItem() }
                print("‚úÖ Items erfolgreich geladen (neues Format ohne Historie): \(items.count) Items")
                
                // Debug: Alle geladenen Items auflisten
                print("üìã Geladene Items:")
                for (index, item) in items.enumerated() {
                    print("  \(index): \(item.id) - \(item.title ?? item.url.absoluteString)")
                }
            } else {
                // Fallback: Versuche als alte URLItems zu laden (mit Historie)
                print("üîÑ Versuche Fallback auf altes Format...")
                if let decoded = try? JSONDecoder().decode([URLItem].self, from: data) {
                    self.items = decoded
                    print("‚úÖ Items erfolgreich geladen (altes Format): \(items.count) Items")
                    
                    // Debug: Alle geladenen Items auflisten
                    print("üìã Geladene Items:")
                    for (index, item) in items.enumerated() {
                        print("  \(index): \(item.id) - \(item.title ?? item.url.absoluteString)")
                    }
                } else {
                    print("‚ùå Fehler beim Decodieren der Items (beide Formate)")
                }
            }
        } else {
            print("üì≠ Keine gespeicherten Daten gefunden")
        }
    }
    

}
